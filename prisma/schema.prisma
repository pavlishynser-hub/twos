// Prisma Schema for TWOS P2P Duel Platform
// Full schema with Skins, Points Exchange, Duels

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ============================================
// USER
// ============================================

model User {
  id            String   @id @default(cuid())
  username      String   @unique
  email         String?  @unique
  passwordHash  String?
  telegramId    String?  @unique
  
  // Balance
  pointsBalance Int      @default(0)
  
  // Rating stats
  totalDeals      Int    @default(0)
  completedDeals  Int    @default(0)
  reliabilityPercent Float @default(100.0)
  
  // Timestamps
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  skins             UserSkin[]
  offersCreated     DuelOffer[]     @relation("OfferCreator")
  matchesAsCreator  DuelMatch[]     @relation("MatchCreator")
  matchesAsOpponent DuelMatch[]     @relation("MatchOpponent")
  bets              DuelBet[]
  transactions      Transaction[]
  gamesWon          DuelGame[]      @relation("GameWinner")
  sessions          Session[]
}

// ============================================
// SESSION (for serverless auth)
// ============================================

model Session {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())
  
  @@index([token])
  @@index([userId])
}

// ============================================
// SKIN (Abstract skin type)
// ============================================

enum SkinRarity {
  COMMON
  UNCOMMON
  RARE
  EPIC
  LEGENDARY
}

model Skin {
  id              String      @id @default(cuid())
  name            String
  description     String?
  imageUrl        String?
  rarity          SkinRarity  @default(COMMON)
  pointsValue     Int         // Nominal point value
  
  // Shop availability
  availableForPurchase Boolean @default(true)
  stockQuantity        Int?    // null = unlimited
  
  // Verification
  skinHash        String?     // hash of metadata + salt
  metadata        Json?
  
  createdAt       DateTime    @default(now())
  
  // Relations
  instances       UserSkin[]
}

// ============================================
// USER SKIN (Concrete instance owned by user)
// ============================================

enum UserSkinStatus {
  ACTIVE
  LOCKED_IN_DUEL
  BURNED
  DONATED_TO_PLATFORM
  CONVERTED_TO_POINTS
}

model UserSkin {
  id            String         @id @default(cuid())
  userId        String
  user          User           @relation(fields: [userId], references: [id])
  skinId        String
  skin          Skin           @relation(fields: [skinId], references: [id])
  
  status        UserSkinStatus @default(ACTIVE)
  instanceHash  String?        // hash: skin_id + user_id + created_at + salt
  
  // If locked in duel
  lockedInMatchId String?
  
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt

  // Relations
  bets          DuelBet[]
  
  @@index([userId])
  @@index([skinId])
  @@index([status])
}

// ============================================
// CHIP TYPES
// ============================================

enum ChipType {
  SMILE  // 5 points
  HEART  // 10 points
  FIRE   // 25 points
  RING   // 50 points
}

// ============================================
// DUEL OFFER (P2P offer on the board)
// ============================================

enum DuelOfferStatus {
  OPEN
  WAITING_CREATOR_CONFIRM
  MATCHED
  CANCELLED
  EXPIRED
}

model DuelOffer {
  id              String          @id @default(cuid())
  
  // Creator
  creatorUserId   String
  creator         User            @relation("OfferCreator", fields: [creatorUserId], references: [id])
  
  // Bet configuration
  chipType        ChipType
  chipPointsValue Int             // 5, 10, 25, or 50
  gamesCount      Int             // Must be >= 2
  
  // Status
  status          DuelOfferStatus @default(OPEN)
  
  // Timing
  createdAt       DateTime        @default(now())
  expiresAt       DateTime?
  
  // Relations
  matches         DuelMatch[]
  
  @@index([status])
  @@index([creatorUserId])
}

// ============================================
// DUEL MATCH (Actual 1v1 match)
// ============================================

enum DuelMatchStatus {
  AWAITING_CREATOR_CONFIRM
  IN_PROGRESS
  FINISHED
  CANCELLED
  CREATOR_NO_SHOW      // Creator didn't confirm
  BOTH_ABANDONED       // Both left before completing
}

model DuelMatch {
  id                    String          @id @default(cuid())
  
  // Offer reference
  offerId               String
  offer                 DuelOffer       @relation(fields: [offerId], references: [id])
  
  // Players
  creatorUserId         String
  creator               User            @relation("MatchCreator", fields: [creatorUserId], references: [id])
  opponentUserId        String
  opponent              User            @relation("MatchOpponent", fields: [opponentUserId], references: [id])
  
  // Games configuration
  gamesPlanned          Int             // From offer.gamesCount
  gamesPlayed           Int             @default(0)
  
  // Status
  status                DuelMatchStatus @default(AWAITING_CREATOR_CONFIRM)
  
  // Confirmation timer
  creatorConfirmDeadline DateTime?
  confirmedAt           DateTime?
  
  // Winner (after all games)
  winnerId              String?
  
  // Timestamps
  createdAt             DateTime        @default(now())
  updatedAt             DateTime        @updatedAt
  finishedAt            DateTime?

  // Relations
  games                 DuelGame[]
  bets                  DuelBet[]
  
  @@index([status])
  @@index([creatorUserId])
  @@index([opponentUserId])
}

// ============================================
// DUEL GAME (Individual game/round in a match)
// ============================================

enum DuelGameStatus {
  PENDING
  AWAITING_READY       // Waiting for both players to be ready
  IN_PROGRESS
  FINISHED
  CANCELLED
  FORFEITED
}

model DuelGame {
  id              String          @id @default(cuid())
  
  // Match reference
  matchId         String
  match           DuelMatch       @relation(fields: [matchId], references: [id])
  
  roundIndex      Int             // 0, 1, 2, ...
  
  // Status
  status          DuelGameStatus  @default(PENDING)
  
  // Fairness (provably fair)
  roundSecret     String?         // Stored, revealed after game
  roundHashCommit String?         // SHA256 of roundSecret, shown before
  
  // Player readiness (for games after first)
  creatorReady    Boolean         @default(false)
  opponentReady   Boolean         @default(false)
  readyDeadline   DateTime?
  
  // Result
  winnerUserId    String?
  winner          User?           @relation("GameWinner", fields: [winnerUserId], references: [id])
  
  // Timestamps
  createdAt       DateTime        @default(now())
  startedAt       DateTime?
  finishedAt      DateTime?
  
  @@unique([matchId, roundIndex])
  @@index([matchId])
}

// ============================================
// DUEL BET (Locked assets in a duel)
// ============================================

enum DuelBetStatus {
  LOCKED
  WON
  LOST
  BURNED_TO_PLATFORM
  RETURNED           // If match cancelled before start
}

model DuelBet {
  id              String        @id @default(cuid())
  
  // Match reference
  matchId         String
  match           DuelMatch     @relation(fields: [matchId], references: [id])
  
  // User
  userId          String
  user            User          @relation(fields: [userId], references: [id])
  
  // Bet (can be skin or points)
  userSkinId      String?
  userSkin        UserSkin?     @relation(fields: [userSkinId], references: [id])
  pointsAmount    Int?          // If betting points instead of skin
  
  // Status
  status          DuelBetStatus @default(LOCKED)
  
  createdAt       DateTime      @default(now())
  resolvedAt      DateTime?
  
  @@index([matchId])
  @@index([userId])
}

// ============================================
// TRANSACTION (Points/Skins history)
// ============================================

enum TransactionType {
  POINTS_TO_SKIN
  SKIN_TO_POINTS
  DUEL_WIN
  DUEL_LOSS
  PENALTY
  DONATION
  BONUS
  INITIAL_BALANCE
}

model Transaction {
  id              String          @id @default(cuid())
  
  userId          String
  user            User            @relation(fields: [userId], references: [id])
  
  type            TransactionType
  amountPoints    Int             // Can be negative
  
  // References
  relatedMatchId  String?
  relatedSkinId   String?
  
  // Details
  description     String?
  metadata        Json?
  
  createdAt       DateTime        @default(now())
  
  @@index([userId])
  @@index([type])
}

// ============================================
// PLATFORM VAULT (Burned skins/points)
// ============================================

model PlatformVault {
  id            String   @id @default(cuid())
  totalPoints   Int      @default(0)
  totalSkins    Int      @default(0)
  updatedAt     DateTime @updatedAt
}
